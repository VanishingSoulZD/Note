# 第一章

**源代码多文件结构**

### CC与gcc
cc和gcc不是同一个东西。cc来自于Unix的c语言编译器，是 c compiler 的缩写。gcc来自Linux世界，是GNU compiler collection 的缩写，注意这是一个编译器集合，不仅仅是c或c++。
linux下的cc是gcc的符号链接(快捷方式)

### 访问main的返回值
echo $?
$?
代表上一个命令执行后的退出状态
如果为 0 说明执行成功。
如果非 0 说明执行失败。
return -1;输出255,因为exit或者main函数中的return, 只能使用0~255之间的值. -1 的unsigned值就是255.

**习惯使用-Wall选项，能对有问题的程序结构发出警告**

**输出运算符<<和输入运算符>>返回其左侧的对象，因此可以将输出/输入请求连接起来**

**std::endl,结束当前行，并将与设备关联的缓冲区中的内容刷到设备中**

### 缓冲区
一个存储区域，用于保存数据。IO设备通常将输入（或输出）数据保存在一个缓冲区中，读写缓冲区的动作与程序中的动作是无关的。我们可以显式的刷新缓冲区，以便强制将缓冲区中的数据写入输出设备。默认情况下，读cin会刷新cout；程序非正常终止时也会刷新cout。

### C++中注释的种类
- 双斜线注释
- 界定符对注释：不能嵌套

# 第二章

**切勿混用带符号类型和无符号类型**  
如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号整数会自动的转换成无符号数。

unsigned int最大值：4294967295  
  
初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值替代。  
  
C++11，列表初始化  
当用于内置类型的变量时，如果我们使用列表初始化且初始化存在丢失信息的风险，则编译器将报错。例如使用long double的值初始化int变量时可能丢失数据。  
  
**声明和定义**  
声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。  
定义负责创建与名字关联的实体。  
变量声明规定了变量的类型和名字。  
定义还申请存储空间，也可能会为变量赋一个初始值。  
如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量。任何包含了显式初始化的声明即成为定义。  
  
C++是一种静态类型语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查。  
  
用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头，定义在函数体外的标识符不能以下划线开头。  
  
因为引用本身不是一个对象，所以不能定义引用的引用。  
引用的类型和与之绑定的对象严格匹配。引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。  
  
因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。  
指针的类型和它所指向的对象严格匹配。  
把int型变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。  
  
void * 是一种特殊的指针类型，可用于存放任意对象的地址。不能直接操作void * 指针所指的对象，因为我们并不知道这个对象是什么类型，也就无法确定能在这个对象上做哪些操作。  
  
因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。  
默认状态下，const对象仅在文件内有效。  
**常量引用是对const的引用。**  
在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。  
允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。  
  
指向常量的指针  
  
const指针，指针是对象而引用不是，因此允许把指针本身定为常量。常量指针必须被初始化，而且一旦初始化完成，则它的值就不能再改变了。把 * 放在const关键字之前用以说明指针是一个常量，意味着不变的是指针本身而非指向的那个值。  
  
常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。   
C++11新标准规定，允许将变量声明为constexpr类型以便编译器来验证变量的值是否是一个常量表达式。  
声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。  
指针和引用能定义成constexpr。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。  
在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。  
  
类型别名：  
typedef  
C++11，别名声明：using 别名 = 类型名；  
  
auto，让编译器去分析表达式所属的类型。  
decltype，选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。（希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量），decltype的表达式如果是加上了括号的变量，结果将是引用。  
  
  



